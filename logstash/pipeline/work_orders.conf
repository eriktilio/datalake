# Configuração de entrada (input) para o plugin File, que permite a leitura de dados de um arquivo de csv.
input {
  file {
    # O caminho do diretório contendo os arquivos de csv.
    path => "/files/csv/*WO*.csv"
    
    # A posição inicial a partir da qual o Logstash começará a ler os arquivos de csv.
    start_position => "beginning"
    
    # O caminho para o sincedb, um banco de dados de estado para rastrear a posição dos arquivos de csv.
    sincedb_path => "/dev/null"
    
    # Uma identificação única para este input, que pode ser útil para gerenciamento e depuração.
    id => "work_orders"
    
    # Adiciona um campo "index" aos eventos, útil para especificar o índice no Elasticsearch.
    add_field => {"index" => "work_orders"}
  }
}

# Configuração do filtro (filter) para processar os eventos lidos do arquivo de csv.
filter {
  csv {
    separator => ","
    columns => ["Work Order", "W/O Target Qty", "SEQ", "Process Name", "Pass Qty", "Fail Qty", "ReTest Pass", "ReTest Fail", "Repass Qty", "Refail Qty", "FPY%", "ReTest Rate%", "Final Yield%", "Group1", "Group2", "Group3", "Group4", "Customer", "spec1"]
    skip_header => true
  }

  # Adicione o filtro date para o campo Process Time
  date {
    match => ["Process Time", "ISO8601"]
    target => "Process Time"
  }

  # Substitua os campos específicos por "N/A" se contiverem apenas espaços em branco
  if [spec1] =~ /^\s*$/ {
    mutate {
      replace => { "spec1" => "N/A" }
    }
  }
}

# Configuração de saída (output) para enviar os dados processados para o Elasticsearch e para a saída padrão (stdout).
output {
  # Configuração de saída para o Elasticsearch, especificando o endereço, usuário, senha, índice e codec.
  elasticsearch {
    hosts => "${ELASTIC_HOST}"
    user => "${ELASTIC_USER}"
    password => "${ELASTIC_PASSWORD}"
    index => "work_orders"
    document_id => "%{Work Order}"        
    # O codec a ser utilizado para codificar os eventos, neste caso, JSON.
    codec => json
  }
  
  # Configuração de saída para a saída padrão (console), utilizando o codec RubyDebug para formatar a saída.
  stdout {
    codec => rubydebug
  }
}
